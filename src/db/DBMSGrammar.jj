options{	// static function을 Instance.foo()로 호출하여 warning이 발생하는 문제가 있어 수정.	static = false;	DEBUG_PARSER = false;	//LOOKAHEAD = "2"; // (default 1)}PARSER_BEGIN(DBMSParser)package db;import java.io.InputStream;import java.io.PrintStream;import dataobject.*;import dataobject.Column.*;import java.util.ArrayList;import com.sleepycat.je.*;import dataobject.Table.*;import dataobject.Condition.*;import dataobject.Record.*;import db.BerkeleyDBHelper.DeleteParam;import db.BerkeleyDBHelper.InsertParam;import db.BerkeleyDBHelper.SelectParam;import db.BerkeleyDBHelper.TableReference;public class DBMSParser{	private PrintStream ps = null;		public static void main(String args []) throws ParseException	{		DBMSParser.run(System.in, System.out, false);	}	public void setPS(PrintStream ps)	{		this.ps = ps;	}	public static void run(InputStream is, PrintStream ps, boolean isTest)	{		DBMSParser parser = new DBMSParser(is);		parser.setPS(ps);		BerkeleyDBHelper.getInstance().openDB();					if( ! isTest)			ps.print(Constant.PROMPT);		if(isTest)			BerkeleyDBHelper.getInstance().setPS(ps);		while (true)		{			try			{				parser.command();			}			catch(EnvironmentLockedException e)			{				ps.println("EnvironmentLockedException occured. Perhaps didn't exit properly. Delete db/*.");				parser.ReInit(is);			}			catch(ParseException e)			{				parser.printMessage(Constant.PRINT_SYNTAX_ERROR);				parser.ReInit(is); // 뼈대 코드에서 SimpleDBMSParser로 되어있는 부분을, non static function 이므로 인스턴스 parser로 변경			}			catch(Exception e)			{				e.printStackTrace();			}			if(isTest)			{				break;			}		}	}	public void printMessage(int q)	{		// Do nothing since project 2 except Syntax Error		if(q != Constant.PRINT_SYNTAX_ERROR)			return;					ps.print(Constant.PROMPT);		switch (q)		{		case Constant.PRINT_SYNTAX_ERROR : 			ps.println(Constant.STR_SYNTAX_ERROR);			break;		/*		case Constant.PRINT_CREATE_TABLE : 			ps.println(Constant.STR_CREATE_TABLE);			break;		case Constant.PRINT_DROP_TABLE :			ps.println(Constant.STR_DROP_TABLE);			break;		case Constant.PRINT_DESC :			ps.println(Constant.STR_DESC);			break;		case Constant.PRINT_SHOW_TABLES :			ps.println(Constant.STR_SHOW_TABLES);			break;		case Constant.PRINT_INSERT :			ps.println(Constant.STR_INSERT);			break;		case Constant.PRINT_DELETE :			ps.println(Constant.STR_DELETE);			break;		case Constant.PRINT_SELECT :			ps.println(Constant.STR_SELECT);			break;		*/		default :			break;		}	}}PARSER_END(DBMSParser)SKIP :{	" "|	"\r"|	"\t"|	"\n"}/* "insert into" 를 "insert"와 "into"로 나눠서 정의하는 이유는, LEGAL_IDENTIFIER에 이런 예약어들이 들어가면 안 되기 때문이다.	더 윗쪽에 정의된 경우 먼저 매칭되기 때문에, 아래 키워드들은 LEGAL_IDENTIFIER에 매칭되지 않는다. 따라서 예약어가 들어가면 자연스럽게 Error가 발생한다. */TOKEN : /* Keywords */{	< EXIT : "exit" >|	< INT : "int" >|	< CHAR : "char" >|	< DATE : "date" >|	< CREATE : "create" >|	< TABLE : "table" >|	< NULL : "null" >|	< NOT : "not" >|	< PRIMARY : "primary" >|	< KEY : "key" >|	< FOREIGN : "foreign" >|	< DROP : "drop" >|	< SHOW : "show" >|	< TABLES : "tables" >|	< IS : "is" >|	< REFERENCES : "references" >|	< DESC : "desc" >|	< SELECT : "select" >|	< AS : "as" >|	< FROM : "from" >|	< WHERE : "where" >|	< OR : "or" >|	< AND : "and" >|	< INSERT : "insert" >|	< INTO : "into" >|	< DELETE : "delete" >|	< VALUES : "values" >|	< DELETE_FROM : < DELETE >" "< FROM > >|	< CREATE_TABLE : < CREATE >" "< TABLE > >|	< NOT_NULL : < NOT >" "< NULL > >|	< PRIMARY_KEY : < PRIMARY >" "< KEY > >|	< FOREIGN_KEY : < FOREIGN >" "< KEY > >|	< IS_NULL : < IS >" "< NULL > >|	< IS_NOT_NULL : < IS >" "< NOT >" "< NULL > >|	< INSERT_INTO : < INSERT >" "< INTO > >|	< DROP_TABLE : < DROP >" "< TABLE > >|	< SHOW_TABLES : < SHOW >" "< TABLES > >}/* R_ 은 Reserved의 약자로, LEGAL_IDENTIFIER에 포함되어서는 안 되는 예약어들을 case insensitive하게 처리하도록 */TOKEN [IGNORE_CASE]:{	< R_EXIT : "exit" >|	< R_INT : "int" >|	< R_CHAR : "char" >|	< R_DATE : "date" >|	< R_CREATE : "create" >|	< R_TABLE : "table" >|	< R_NULL : "null" >|	< R_NOT : "not" >|	< R_PRIMARY : "primary" >|	< R_KEY : "key" >|	< R_FOREIGN : "foreign" >|	< R_DROP : "drop" >|	< R_SHOW : "show" >|	< R_TABLES : "tables" >|	< R_IS : "is" >|	< R_REFERENCES : "references" >|	< R_DESC : "desc" >|	< R_SELECT : "select" >|	< R_AS : "as" >|	< R_FROM : "from" >|	< R_WHERE : "where" >|	< R_OR : "or" >|	< R_AND : "and" >|	< R_INSERT : "insert" >|	< R_INTO : "into" >|	< R_DELETE : "delete" >|	< R_VALUES : "values" >} TOKEN : /* Operators */{	< SEMICOLON : ";" >|	< LEFT_PAREN : "(" >|	< RIGHT_PAREN : ")" >|	< SIGN :		"+"	|	"-" >|	< COMP_OP :		"<"	|	">"	|	"="	|	">="	|	"<="	|	"!=" >}TOKEN : /* Symbol */{	< COMMA : "," >|	< UNDERSCORE : "_" >|	< QUOTE : "'" >|	< ASTERISK : "*" >|	< PERIOD : "." >}TOKEN : /* Data Types & Names */{	< #DIGIT : [ "0"-"9" ] >|	< LEGAL_IDENTIFIER :		//"int" "select" 와 같은 예약어들은 위에 정의되어 있어서 자동으로 빠지는 구조이다. 		< ALPHABET >		(			< ALPHABET >		|	< UNDERSCORE >		)* >|	< ALPHABET : [ "A"-"Z", "a"-"z" ] >|	< INT_VALUE : (< SIGN >)?(< DIGIT >)+ >|	< DATE_VALUE : < NNNN >"-"< NN >"-"< NN >>|	< NNNN : < DIGIT >< DIGIT >< DIGIT >< DIGIT >>|	< NN : < DIGIT >< DIGIT >>|	< NON_QUOTE_SPECIAL_CHARACTERS : ("`" | "~" | "!" | "@" | "#" | "$" | "%" | "^" | "&"									| "*" | "(" | ")" | "-" | "_" | "+" | "=" | "[" | "]"									| "{" | "}" | ";" | ":" | "<" | ">" | "," | "." | "/"									| "?" | "|" | "\\") >|	< NON_QUOTE_CHARACTER : < DIGIT >							| < ALPHABET >							| < NON_QUOTE_SPECIAL_CHARACTERS >							| " ">	//SPACE를 따로 정의하면 SKIP의 " "와 중복됨|	< CHAR_STRING : < QUOTE >(< NON_QUOTE_CHARACTER >)*< QUOTE >>}void command() :{}{	queryList()	|	(		< EXIT > 		< SEMICOLON >		{			BerkeleyDBHelper.getInstance().closeDB();			System.exit(0);		}	)}void queryList() :{}{	(		query()	)+}void query() :{	Table table;	ArrayList<String> nameList;	SelectParam selectParam;	InsertParam insertParam;	DeleteParam deleteParam;}{	(		table = createTableQuery()		< SEMICOLON >		{			BerkeleyDBHelper.getInstance().createTable(table);		}	)|	(		nameList = dropTableQuery()		< SEMICOLON >		{			BerkeleyDBHelper.getInstance().dropTable(nameList);		}	)|	(		nameList = descQuery()		< SEMICOLON >		{			BerkeleyDBHelper.getInstance().desc(nameList);		}	)	// Grammar가 바뀌어서 일단 뺌/*|	(		showTablesQuery()		{		}	)*/|	(		selectParam = selectQuery()		< SEMICOLON >		{			BerkeleyDBHelper.getInstance().select(selectParam.scList,												selectParam.tableList,												selectParam.cond);		}	)|	(		insertParam = insertQuery()		< SEMICOLON >		{			BerkeleyDBHelper.getInstance().insert(insertParam.tableName,												insertParam.columnNameList,												insertParam.valueList);		}	)|	(		deleteParam = deleteQuery()		< SEMICOLON >		{			BerkeleyDBHelper.getInstance().delete(deleteParam.tableName,												deleteParam.cond);		}	)}Table createTableQuery() :{	Table table;	String tableName;}{	< CREATE_TABLE > 	tableName = tableName()	{		table = new Table(tableName);	}	tableElementList(table)	{		return table;	}}ArrayList<String> dropTableQuery() :{	ArrayList<String> arr;}{	< DROP_TABLE >	arr = tableNameList()	{		return arr;	}}ArrayList<String> descQuery() :{	ArrayList<String> arr;}{	< DESC >	arr = tableNameList()	{		return arr;	}}void showTablesQuery() :{}{	< SHOW_TABLES >}SelectParam selectQuery() :{	SelectParam param = new SelectParam();}{	< SELECT >	param.scList = selectList()	tableExpression(param)	{		return param;	}}InsertParam insertQuery() :{	InsertParam param = new InsertParam();}{	< INSERT_INTO >	param.tableName = tableName()	insertColumnsAndSource(param)	{		return param;	}}DeleteParam deleteQuery() : {	DeleteParam param = new DeleteParam();	param.cond = null;}{	< DELETE_FROM >	param.tableName = tableName()	(		param.cond = whereClause()	)?	{		return param;	}}/*** Insert / Delete*/void insertColumnsAndSource(InsertParam param) :{	// columnNameList가 없으면 null로 처리하도록 	param.columnNameList = null;}{	(		param.columnNameList = columnNameList()	)?	param.valueList = valueList()}ArrayList<Value> valueList() :{	ArrayList<Value> arr = new ArrayList<Value>();	Value val;}{	< VALUES >	< LEFT_PAREN >	val = value()	{		arr.add(val);	}	(		< COMMA >		val = value()		{			arr.add(val);		}	)*	< RIGHT_PAREN >	{		return arr;	}}Value value() :{	Value val;	_ConstantOperand op;}{(	< NULL >	{		val = new NullValue();	}	|		op = comparableValue()	{		val = op.convertToValue();	})	{		return val;	}}/*** Select*/ArrayList<SelectedColumn> selectList() :{	ArrayList<SelectedColumn> scList = new ArrayList<SelectedColumn>();	SelectedColumn sc;}{	< ASTERISK >	{		return null;	}|	(		sc = selectedColumn()		{			scList.add(sc);		}		(			< COMMA >			sc = selectedColumn()			{				scList.add(sc);			}		)*	)	{		return scList;	}}SelectedColumn selectedColumn() :{	SelectedColumn sc;	_ColumnOperand op;	String colAlias = null;}{	op = column()	(		< AS >		colAlias = columnName()	)?	{		sc = new SelectedColumn(op.tableName, op.colName, colAlias);		return sc;	}}void tableExpression(SelectParam param) :{}{	param.tableList = fromClause()	(		param.cond = whereClause()	)?}ArrayList<TableReference> fromClause() :{	ArrayList<TableReference> arr;}{	< FROM >	arr = tableReferenceList()	{		return arr;	}}ArrayList<TableReference> tableReferenceList() :{	ArrayList<TableReference> arr = new ArrayList<TableReference>();	TableReference tr;}{	tr = referedTable()	{		arr.add(tr);	}	(		< COMMA >		tr = referedTable()		{			arr.add(tr);		}	)*	{		return arr;	}}TableReference referedTable() :{	TableReference tr = new TableReference();}{	tr.tableName = tableName()	(		< AS >		tr.alias = tableName()	)?	{		return tr;	}}_Condition whereClause() :{	_Condition cond;}{	< WHERE >	cond = booleanValueExpression()	{		return cond;	}}// OR과 AND의 순서 : http://stackoverflow.com/questions/16805630/and-or-order-of-operations// 보통 AND를 먼저 evaluate_Condition booleanValueExpression() :{	_OrCondition orCond = new _OrCondition();	_Condition cond;}{	cond = booleanTerm()	{		orCond.orList.add(cond);	}	(		< OR >		cond = booleanTerm()		{			orCond.orList.add(cond);		}	)*	{		return orCond;	}}_Condition booleanTerm() :{	_AndCondition andCond = new _AndCondition();	_Condition cond;	}{	cond = booleanFactor()	{		andCond.andList.add(cond);	}	(		< AND >		cond = booleanFactor()		{			andCond.andList.add(cond);		}	)*	{		return andCond;	}}_Condition booleanFactor() :{	boolean isNot = false;	_Condition cond;}{	(		< NOT >		{			isNot = true;		}	)?	cond = booleanTest()	{		if(isNot)			cond.isNot = true;		return cond;	}}_Condition booleanTest() :{	_Condition cond;}{(	cond = predicate()|	cond = parenthesizedBooleanExpression())	{		return cond;	}}_Condition parenthesizedBooleanExpression() :{	_Condition cond;}{	< LEFT_PAREN >	cond = booleanValueExpression()	< RIGHT_PAREN >	{		return cond;	}}_Condition predicate() :{	_Condition cond;	_Operand left, right;	Token o;	boolean isNull;}{	left = compOperand()	(		(			o = < COMP_OP >			right = compOperand()		)		{			String operator = o.image;			cond = new _ComparisonCondition(left, operator, right);		}	|		(			(				< IS_NULL >				{					isNull = true;				}				|				< IS_NOT_NULL >				{					isNull = false;				}			)			{				cond = new _NullCondition(left, isNull);			}		)	)	{		return cond;	}	//첫 번째 compOperand()가 column이 아닌 < COMPARABLE_VALUE > 인데 NULL OP가 오면 에러	// -> 처리함}_Operand compOperand() :{	_Operand op;}{(			op = comparableValue()|	op = column())	{		return op;	}}_ColumnOperand column() :{	_ColumnOperand op = new _ColumnOperand();}{	( LOOKAHEAD(2)		op.tableName = tableName()		< PERIOD >	)?	op.colName = columnName()	{		return op;	}}_ConstantOperand comparableValue() :{	_ConstantOperand op = new _ConstantOperand();	Token t;}{(		(		t = < INT_VALUE >		{			op.pType = PRIMITIVE_TYPE.INT;			op.iValue = Integer.parseInt(t.image);		}	)|	(		t = < CHAR_STRING >		{			op.pType = PRIMITIVE_TYPE.CHAR;			op.sValue = t.image;		}	)|	(		t = < DATE_VALUE >		{			op.pType = PRIMITIVE_TYPE.DATE;			op.sValue = t.image;		}	))	{		return op;	}}/*** Create Table, Drop Table, Desc*/ArrayList<String> tableNameList() :{	ArrayList<String> arr = new ArrayList<String>();	String name;}{(	< ASTERISK >	{		// It means Asterisk, BerkeleyDBHelper에서 *로 처리함		arr = null;	}|	name = tableName()	{		arr.add(name);	}	(		< COMMA >		name = tableName()		{			arr.add(name);		}	)*)	{		return arr;	}}void tableElementList(Table table) :{}{	< LEFT_PAREN > 	tableElement(table)	(		< COMMA > 		tableElement(table)	)*	< RIGHT_PAREN >}void tableElement(Table table) :{}{	columnDefinition(table)|	tableConstraintDefinition(table)}void columnDefinition(Table table) :{	Token t;	String columnName;	Type columnType;	boolean isNotNull = false;}{	columnName = columnName() 	columnType = dataType() 	(		< NOT_NULL >		{			isNotNull = true;		}	)?	{		Column c = new Column(columnName, columnType, isNotNull);		table.addColumn(c);	}}void tableConstraintDefinition(Table table) :{}{	primaryKeyConstraint(table)|	referentialConstraint(table)}void primaryKeyConstraint(Table table) :{	ArrayList<String> columnList;}{	< PRIMARY_KEY > 	columnList = columnNameList()	{		table.setPrimaryKey(columnList);	}}void referentialConstraint(Table table) :{	ArrayList<String> columnList;	ArrayList<String> rColumnList;	String rTableName;}{	< FOREIGN_KEY > 	columnList = columnNameList() 	< REFERENCES > 	rTableName = tableName() 	rColumnList = columnNameList()	{		FK fk = new FK(table.getName(), columnList, rTableName, rColumnList);		table.addForeignKey(fk);	}}ArrayList<String> columnNameList() :{	ArrayList<String> arr = new ArrayList<String>();	String name;}{(			< LEFT_PAREN > 	name = columnName()	{		arr.add(name);	}	(		< COMMA > 		name = columnName()		{			arr.add(name);		}	)*	< RIGHT_PAREN >)	{		return arr;	}}Type dataType() :{	Token t;	Token l = null;}{	(			t = < INT >|	(	t = < CHAR > 	< LEFT_PAREN > 	l = < INT_VALUE > 	< RIGHT_PAREN >	)|	t = < DATE >	)	{		Type type;		if("int".equals(t.image))			type = new Type(PRIMITIVE_TYPE.INT, 0);		else if("date".equals(t.image))			type = new Type(PRIMITIVE_TYPE.DATE, 0);		else		{			int length = Integer.parseInt(l.image);			type = new Type(PRIMITIVE_TYPE.CHAR, length);		}		return type;	}}String tableName() :{	Token t;}{	t = < LEGAL_IDENTIFIER >	{		return t.image;	}}String columnName() :{	Token t;}{	t = < LEGAL_IDENTIFIER >	{		return t.image;	}}